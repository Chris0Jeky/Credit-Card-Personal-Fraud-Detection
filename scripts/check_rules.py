import pandas as pd
import json
from pathlib import Path
from geopy.distance import geodesic
from datetime import datetime, timedelta

# --- Configuration ---
# Input files generated by simulate_entities.py
SIMULATION_DIR = Path(__file__).parent.parent / "data" / "simulation_output"
ACCOUNT_DETAILS_FILE = SIMULATION_DIR / "simulated_account_details.json"
TRANSACTIONS_FILE = SIMULATION_DIR / "simulated_account_transactions.csv"

# Rule Thresholds
LOCATION_THRESHOLD_KM = 500  # Max distance from home for a 'normal' transaction
HIGH_AMOUNT_THRESHOLD = 1000 # Example: Flag transactions over $1000
RECENT_ACCOUNT_DAYS = 30     # Definition of a 'recent' account for velocity checks
RECENT_ACCOUNT_HIGH_VELOCITY_THRESHOLD = 5 # Max transactions in 24h for recent account
# ---

def calculate_distance(lat1, lon1, lat2, lon2):
    """Calculate distance in kilometers between two lat/lon points."""
    if pd.isna(lat1) or pd.isna(lon1) or pd.isna(lat2) or pd.isna(lon2):
        return float('inf') # Indicate missing data
    try:
        return geodesic((lat1, lon1), (lat2, lon2)).km
    except ValueError:
        print(f"Warning: Invalid coordinates for distance calculation ({lat1},{lon1}) to ({lat2},{lon2})")
        return float('inf') # Indicate calculation error

def check_transaction_rules(transaction_row, account_details, recent_transactions):
    """
    Applies rules to a single transaction.
    `recent_transactions` is a list of timestamps from the last 24h for velocity checks.
    """
    flags = []
    account_lat = account_details.get('lat')
    account_lon = account_details.get('long')
    account_creation_str = account_details.get('account_creation_date')

    # --- Date Checks ---
    trans_dt = None
    try:
        # Handle potential variations in timestamp format if necessary
        trans_dt = pd.to_datetime(transaction_row['trans_date_trans_time'])
    except (ValueError, TypeError) as e:
        flags.append(f"INVALID_TIMESTAMP ({e})")

    acc_creation_dt = None
    if account_creation_str:
        try:
            acc_creation_dt = datetime.fromisoformat(account_creation_str)
        except (ValueError, TypeError) as e:
            flags.append(f"INVALID_ACCOUNT_DATE_FORMAT ({e})")

    # Rule 1: Transaction before account creation
    if trans_dt and acc_creation_dt and trans_dt < acc_creation_dt:
        flags.append(
            f"RULE_VIOLATION:TRANSACTION_BEFORE_ACCOUNT_CREATION ({trans_dt.date()} vs {acc_creation_dt.date()})")

    # --- Location Checks ---
    # Rule 2: Transaction far from account home location
    if 'merch_lat' in transaction_row and 'merch_long' in transaction_row and account_lat is not None and account_lon is not None:
        distance = calculate_distance(
            transaction_row['merch_lat'], transaction_row['merch_long'],
            account_lat, account_lon
        )
        if distance > LOCATION_THRESHOLD_KM:
            flags.append(f"RULE_VIOLATION:LOCATION_FAR_FROM_HOME ({distance:.0f}km > {LOCATION_THRESHOLD_KM}km)")
    else:
        flags.append("INFO:Missing_Coordinates_For_Location_Check")

    # --- Amount Checks ---
    # Rule 3: High transaction amount
    if 'amt' in transaction_row:
        amount = pd.to_numeric(transaction_row['amt'], errors='coerce')
        if pd.notna(amount) and amount > HIGH_AMOUNT_THRESHOLD:
            flags.append(f"RULE_VIOLATION:HIGH_AMOUNT (${amount:.2f} > ${HIGH_AMOUNT_THRESHOLD})")
        elif pd.isna(amount):
            flags.append("INFO:Missing_Amount_For_Check")

    # --- Velocity Checks ---
    # Rule 4: High velocity for recently created account
    if acc_creation_dt and trans_dt:
        account_age = trans_dt - acc_creation_dt
        if account_age.days <= RECENT_ACCOUNT_DAYS:
            # Count transactions within the last 24 hours of the current transaction
            one_day_before = trans_dt - timedelta(days=1)
            count_last_24h = sum(
                1 for ts in recent_transactions if ts >= one_day_before and ts < trans_dt)  # Exclude current trans
            # Add 1 for the current transaction itself when comparing to threshold
            if (count_last_24h + 1) > RECENT_ACCOUNT_HIGH_VELOCITY_THRESHOLD:
                flags.append(
                    f"RULE_VIOLATION:HIGH_VELOCITY_RECENT_ACCOUNT ({count_last_24h + 1} trans in 24h > {RECENT_ACCOUNT_HIGH_VELOCITY_THRESHOLD})")

    # Add more rules here: time of day, specific merchant/category flags, etc.
    return flags

def main():
    """Main rule checking logic."""
    print("--- Starting Rule-Based Checks ---")

    # 1. Load simulated account details
    print(f"Loading account details from {ACCOUNT_DETAILS_FILE}...")
    try:
        with open(ACCOUNT_DETAILS_FILE, 'r') as f:
            account_details = json.load(f)
        print(f"   Loaded details for account {account_details.get('account_id', 'N/A')}")
    except FileNotFoundError:
        print(f"Error: Account details file not found at {ACCOUNT_DETAILS_FILE}")
        return
    except Exception as e:
        print(f"Error loading account details: {e}")
        return

    # 2. Load simulated transactions
    print(f"Loading transactions from {TRANSACTIONS_FILE}...")
    try:
        transactions_df = pd.read_csv(TRANSACTIONS_FILE)
        # Convert timestamp column for easier handling
        transactions_df['trans_ts'] = pd.to_datetime(transactions_df['trans_date_trans_time'], errors='coerce')
        # Sort by time for velocity checks
        transactions_df = transactions_df.sort_values(by='trans_ts').reset_index(drop=True)
        print(f"   Loaded {len(transactions_df)} transactions.")
    except FileNotFoundError:
        print(f"Error: Transactions file not found at {TRANSACTIONS_FILE}")
        return
    except Exception as e:
        print(f"Error loading or processing transactions: {e}")
        return

    # 3. Apply rules transaction by transaction
    print("\nApplying rules to transactions...")
    flagged_count = 0
    all_timestamps = transactions_df['trans_ts'].dropna().tolist()  # List of all valid timestamps

    results = []  # Store results for potential later use

    for index, transaction in transactions_df.iterrows():
        # Get timestamps relevant for velocity check (up to current transaction)
        relevant_timestamps = [ts for ts in all_timestamps if ts < transaction['trans_ts']]

        flags = check_transaction_rules(transaction, account_details, relevant_timestamps)

        result_data = transaction.to_dict()
        result_data['rule_flags'] = flags

        results.append(result_data)

        if flags:
            flagged_count += 1
            print(f"\n--- Transaction {index} ({transaction['trans_num']}) ---")
            print(f"  Timestamp: {transaction['trans_date_trans_time']}")
            print(f"  Amount: {transaction['amt']:.2f}, Merchant: {transaction['merchant']}")
            print(f"  !! Flags Triggered: {'; '.join(flags)}")

    if flagged_count == 0:
        print("\nNo transactions flagged by the defined rules.")
    else:
        print(
            f"\n--- Summary: {flagged_count} out of {len(transactions_df)} transactions triggered one or more rules. ---")

    # Save results with flags added
    results_df = pd.DataFrame(results)
    results_output_file = SIMULATION_DIR / "simulated_transactions_with_flags.csv"
    results_df.to_csv(results_output_file, index=False)
    print(f"Results with flags saved to {results_output_file}")

    print("--- Rule Checking Complete ---")

if __name__ == "__main__":
    main()
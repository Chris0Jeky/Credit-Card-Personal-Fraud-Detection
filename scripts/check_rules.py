import pandas as pd
import json
from pathlib import Path
from geopy.distance import geodesic
from datetime import datetime, timedelta

# --- Configuration ---
# Input files generated by simulate_entities.py
SIMULATION_DIR = Path("../data/simulation_output")
ACCOUNT_DETAILS_FILE = SIMULATION_DIR / "simulated_account_details.json"
TRANSACTIONS_FILE = SIMULATION_DIR / "simulated_account_transactions.csv"

# Rule Thresholds
LOCATION_THRESHOLD_KM = 500  # Max distance from home for a 'normal' transaction
HIGH_AMOUNT_THRESHOLD = 1000 # Example: Flag transactions over $1000
RECENT_ACCOUNT_DAYS = 30     # Definition of a 'recent' account for velocity checks
RECENT_ACCOUNT_HIGH_VELOCITY_THRESHOLD = 5 # Max transactions in 24h for recent account
# ---

def calculate_distance(lat1, lon1, lat2, lon2):
    """Calculate distance in kilometers between two lat/lon points."""
    if pd.isna(lat1) or pd.isna(lon1) or pd.isna(lat2) or pd.isna(lon2):
        return float('inf') # Indicate missing data
    try:
        return geodesic((lat1, lon1), (lat2, lon2)).km
    except ValueError:
        print(f"Warning: Invalid coordinates for distance calculation ({lat1},{lon1}) to ({lat2},{lon2})")
        return float('inf') # Indicate calculation error

def check_transaction_rules(transaction_row, account_details, recent_transactions):
    """
    Applies rules to a single transaction.
    `recent_transactions` is a list of timestamps from the last 24h for velocity checks.
    """
    flags = []
    account_lat = account_details.get('lat')
    account_lon = account_details.get('long')
    account_creation_str = account_details.get('account_creation_date')

    # --- Date Checks ---
    trans_dt = None
    try:
        # Handle potential variations in timestamp format if necessary
        trans_dt = pd.to_datetime(transaction_row['trans_date_trans_time'])
    except (ValueError, TypeError) as e:
        flags.append(f"INVALID_TIMESTAMP ({e})")

    acc_creation_dt = None
    if account_creation_str:
        try:
            acc_creation_dt = datetime.fromisoformat(account_creation_str)
        except (ValueError, TypeError) as e:
            flags.append(f"INVALID_ACCOUNT_DATE_FORMAT ({e})")

    # Rule 1: Transaction before account creation
    if trans_dt and acc_creation_dt and trans_dt < acc_creation_dt:
        flags.append(
            f"RULE_VIOLATION:TRANSACTION_BEFORE_ACCOUNT_CREATION ({trans_dt.date()} vs {acc_creation_dt.date()})")

    # --- Location Checks ---
    # Rule 2: Transaction far from account home location
    if 'merch_lat' in transaction_row and 'merch_long' in transaction_row and account_lat is not None and account_lon is not None:
        distance = calculate_distance(
            transaction_row['merch_lat'], transaction_row['merch_long'],
            account_lat, account_lon
        )
        if distance > LOCATION_THRESHOLD_KM:
            flags.append(f"RULE_VIOLATION:LOCATION_FAR_FROM_HOME ({distance:.0f}km > {LOCATION_THRESHOLD_KM}km)")
    else:
        flags.append("INFO:Missing_Coordinates_For_Location_Check")

    # --- Amount Checks ---
    # Rule 3: High transaction amount
    if 'amt' in transaction_row:
        amount = pd.to_numeric(transaction_row['amt'], errors='coerce')
        if pd.notna(amount) and amount > HIGH_AMOUNT_THRESHOLD:
            flags.append(f"RULE_VIOLATION:HIGH_AMOUNT (${amount:.2f} > ${HIGH_AMOUNT_THRESHOLD})")
        elif pd.isna(amount):
            flags.append("INFO:Missing_Amount_For_Check")

    # --- Velocity Checks ---
    # Rule 4: High velocity for recently created account
    if acc_creation_dt and trans_dt:
        account_age = trans_dt - acc_creation_dt



